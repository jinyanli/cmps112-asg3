<html lang="en">
<head>
<title>Object representation - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="C-and-Smalltalk.html#C-and-Smalltalk" title="C and Smalltalk">
<link rel="prev" href="Smalltalk-callbacks.html#Smalltalk-callbacks" title="Smalltalk callbacks">
<link rel="next" href="Incubator.html#Incubator" title="Incubator">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Object-representation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Incubator.html#Incubator">Incubator</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Smalltalk-callbacks.html#Smalltalk-callbacks">Smalltalk callbacks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="C-and-Smalltalk.html#C-and-Smalltalk">C and Smalltalk</a>
<hr>
</div>

<h3 class="section">5.8 Manipulating instances of your own Smalltalk classes from C</h3>

<p>Although <span class="sc">gnu</span> Smalltalk's library exposes functions to deal with instances of
the most common base class, it's likely that, sooner or later, you'll
want your C code to directly deal with instances of classes defined by
your program.  There are three steps in doing so:

     <ul>
<li>Defining the Smalltalk class
<li>Defining a C <code>struct</code> that maps the representation of the class
<li>Actually using the C struct
</ul>

   <p>In this chapter you will be taken through these steps considering the
hypotetical task of defining a Smalltalk interface to an SQL server.

   <p>The first part is also the simplest, since defining the Smalltalk class
can be done in a single way which is also easy and very practical; just
evaluate the standard Smalltalk code that does that:

<pre class="example">         Object subclass: SQLAction [
              | database request |
              &lt;category: 'SQL-C interface'&gt;
         ]
     
         SQLAction subclass: SQLRequest [
              | returnedRows |
              &lt;category: 'SQL-C interface'&gt;
         ]
</pre>
   <p>To define the C <code>struct</code> for a class derived from Object, <span class="sc">gnu</span> Smalltalk's
<code>gstpub.h</code> include file defines an <code>OBJ_HEADER</code> macro which
defines the fields that constitute the header of every object.  Defining
a <code>struct</code> for SQLAction results then in the following code:

<pre class="example">         struct st_SQLAction {
             OBJ_HEADER;
             OOP database;
             OOP request;
         }
</pre>
   <p>The representation of SQLRequest in memory is this:

<pre class="example">         .------------------------------.
         |     common object header     |    2 longs
         |------------------------------|
         | SQLAction instance variables |
         |           database           |    2 longs
         |           request            |
         |------------------------------|
         | SQLRequest instance variable |
         |         returnedRows         |    1 long
         '------------------------------'
</pre>
   <p>A first way to define the struct would then be:
<pre class="example">         typedef struct st_SQLAction {
             OBJ_HEADER;
             OOP database;
             OOP request;
             OOP returnedRows;
         } *SQLAction;
</pre>
   <p>but this results in a lot of duplicated code.  Think of what would
happen if you had other subclasses of <code>SQLAction</code> such as
<code>SQLObjectCreation</code>, <code>SQLUpdateQuery</code>, and so on! The
solution, which is also the one used in <span class="sc">gnu</span> Smalltalk's source code is to
define a macro for each superclass, in this way:

<pre class="example">         /* SQLAction
             |-- SQLRequest
             |     `-- SQLUpdateQuery
             `-- SQLObjectCreation       */
     
         #define ST_SQLACTION_HEADER         \
             OBJ_HEADER;                     \
             OOP database;                   \
             OOP request                     /* no semicolon */
     
         #define ST_SQLREQUEST_HEADER        \
             ST_SQLACTION_HEADER;            \
             OOP returnedRows                /* no semicolon */
     
         typedef struct st_SQLAction {
             ST_SQLACTION_HEADER;
         } *SQLAction;
     
         typedef struct st_SQLRequest {
             ST_SQLREQUEST_HEADER;
         } *SQLRequest;
     
         typedef struct st_SQLObjectCreation {
             ST_SQLACTION_HEADER;
             OOP newDBObject;
         } *SQLObjectCreation;
     
         typedef struct st_SQLUpdateQuery {
             ST_SQLREQUEST_HEADER;
             OOP numUpdatedRows;
         } *SQLUpdateQuery;
</pre>
   <p>Note that the macro you declare is used instead of <code>OBJ_HEADER</code> in
the declaration of both the superclass and the subclasses.

   <p>Although this example does not show that, please note that you should
not declare anything if the class has indexed instance variables.

   <p>The first step in actually using your structs is obtaining a pointer to
an OOP which is an instance of your class.  Ways to do so include doing
a call-in, receiving the object from a call-out (using
<code>#smalltalk</code>, <code>#self</code> or <code>#selfSmalltalk</code> as the type
specifier).

   <p>Let's assume that the <code>oop</code> variable contains such an object. 
Then, you have to dereference the OOP (which, as you might recall from
<a href="Smalltalk-types.html#Smalltalk-types">Smalltalk types</a>, point to the actual object only indirectly) and
get a pointer to the actual data.  You do that with the
<code>OOP_TO_OBJ</code> macro (note the type casting):

<pre class="example">         SQLAction action = (SQLAction) OOP_TO_OBJ(oop);
</pre>
   <p>Now you can use the fields in the object like in this pseudo-code:

<pre class="example">         /* These are retrieved via classNameToOOP and then cached in global
            variables */
         OOP sqlUpdateQueryClass, sqlActionClass, sqlObjectCreationClass;
         <span class="roman">...</span>
         invoke_sql_query(
             vmProxy-&gt;oopToCObject(action-&gt;database),
             vmProxy-&gt;oopToString(action-&gt;request);
             query_completed_callback,       /* Callback function */
             oop);                           /* Passed to the callback */
     
         ...
     
         /* Imagine that invoke_sql_query runs asynchronously and calls this
            when the job is done. */
         void
         query_completed_callback(result, database, request, clientData)
              struct query_result *result;
              struct db *database;
              char *request;
              OOP clientData;
         {
           SQLUpdateQuery query;
           OOP rows;
           OOP cObject;
     
           /* Free the memory allocated by oopToString */
           free(request);
     
           if (OOP_CLASS (oop) == sqlActionClass)
             return;
     
           if (OOP_CLASS (oop) == sqlObjectCreationClass)
             {
               SQLObjectCreation oc;
               oc = (SQLObjectCreation) OOP_TO_OBJ (clientData);
               cObject = vmProxy-&gt;cObjectToOOP (result-&gt;dbObject)
               oc-&gt;newDBObject = cObject;
             }
           else
             {
               /* SQLRequest or SQLUpdateQuery */
               cObject = vmProxy-&gt;cObjectToOOP (result-&gt;rows);
               query = (SQLUpdateQuery) OOP_TO_OBJ (clientData);
               query-&gt;returnedRows = cObject;
               if (OOP_CLASS (oop) == sqlUpdateQueryClass)
                 query-&gt;numReturnedRows = vmProxy-&gt;intToOOP (result-&gt;count);
             }
     
         }
     
</pre>
   <p>Note that the result of <code>OOP_TO_OBJ</code> is not valid anymore if a
garbage-collection happens; for this reason, you should assume that a
pointer to object data is not valid after doing a call-in, calling
<code>objectAlloc</code>, and using any of the &ldquo;C to Smalltalk&rdquo; functions
except <code>intToOOP</code> (see <a href="Smalltalk-types.html#Smalltalk-types">Smalltalk types</a>).  That's why I passed
the OOP to the callback, not the object pointer itself.

   <p>If your class has indexed instance variables, you can use the
<code>INDEXED_WORD</code>, <code>INDEXED_OOP</code> and <code>INDEXED_BYTE</code> macros
declared in <code>gstpub.h</code>, which return an lvalue for the given
indexed instance variable&mdash;for more information, see <a href="Other-C-functions.html#Other-C-functions">Other C functions</a>.

   </body></html>

