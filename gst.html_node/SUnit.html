<html lang="en">
<head>
<title>SUnit - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Packages.html#Packages" title="Packages">
<link rel="prev" href="Swazoo.html#Swazoo" title="Swazoo">
<link rel="next" href="Network-support.html#Network-support" title="Network support">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="SUnit"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Network-support.html#Network-support">Network support</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Swazoo.html#Swazoo">Swazoo</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Packages.html#Packages">Packages</a>
<hr>
</div>

<h3 class="section">3.7 The SUnit testing package</h3>

<p><code>SUnit</code> is a framework to write and perform test cases in Smalltalk,
originarily written by the father of Extreme Programming<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>,
Kent Beck.  <code>SUnit</code> allows one to write the tests and check
results in Smalltalk; while this approach has the disadvantage that
testers need to be able to write simple Smalltalk programs, the
resulting tests are very stable.

   <p>What follows is a description of the philosophy of <code>SUnit</code> and
a description of its usage, excerpted from Kent Beck's paper in which
he describes <code>SUnit</code>.

<h4 class="subsection">3.7.1 Where should you start?</h4>

<p>Testing is one of those impossible tasks. You'd like to be absolutely
complete, so you can be sure the software will work.  On the other hand,
the number of possible states of your program is so large that you can't
possibly test all combinations.

   <p>If you start with a vague idea of what you'll be testing, you'll never
get started. Far better to <em>start with a single configuration whose
behavior is predictable</em>. As you get more experience with your software,
you will be able to add to the list of configurations.

   <p>Such a configuration is called a <dfn>fixture</dfn>.  Two example fixtures
for testing Floats can be <code>1.0</code> and <code>2.0</code>; two fixtures for
testing Arrays can be <code>#()</code> and <code>#(1 2 3)</code>.

   <p>By choosing a fixture you are saying what you will and won't test for. A
complete set of tests for a community of objects will have many
fixtures, each of which will be tested many ways.

   <p>To design a test fixture you have to
     <ul>
<li>Subclass TestCase
<li>Add an instance variable for each known object in the fixture
<li>Override setUp to initialize the variables
</ul>

<h4 class="subsection">3.7.2 How do you represent a single unit of testing?</h4>

<p>You can predict the results of sending a message to a fixture. You need
to represent such a predictable situation somehow.  The simplest way to
represent this is interactively. You open an Inspector on your fixture
and you start sending it messages. There are two drawbacks to this
method. First, you keep sending messages to the same fixture.  If a test
happens to mess that object up, all subsequent tests will fail, even
though the code may be correct.

   <p>More importantly, though, you can't easily communicate interactive tests
to others. If you give someone else your objects, the only way they have
of testing them is to have you come and inspect them.

   <p>By representing each predictable situation as an object, each with its
own fixture, no two tests will ever interfere. Also, you can easily give
tests to others to run. <em>Represent a predictable reaction of a
fixture as a method.</em>  Add a method to TestCase subclass, and stimulate
the fixture in the method.

<h4 class="subsection">3.7.3 How do you test for expected results?</h4>

<p>If you're testing interactively, you check for expected results
directly, by printing and inspecting your objects.  Since tests are in
their own objects, you need a way to programmatically look for
problems. One way to accomplish this is to use the standard error
handling mechanism (<code>#error:</code>) with testing logic to signal errors:

<pre class="example">     2 + 3 = 5 ifFalse: [self error: 'Wrong answer']
</pre>
   <p>When you're testing, you'd like to distinguish between errors you are
checking for, like getting six as the sum of two and three, and errors
you didn't anticipate, like subscripts being out of bounds or messages
not being understood.

   <p>There's not a lot you can do about unanticipated errors (if you did
something about them, they wouldn't be unanticipated any more, would
they?) When a catastrophic error occurs, the framework stops running the
test case, records the error, and runs the next test case. Since each
test case has its own fixture, the error in the previous case will not
affect the next.

   <p>The testing framework makes checking for expected values simple by
providing a method, <code>#should:</code>, that takes a Block as an argument. 
If the Block evaluates to true, everything is fine. Otherwise, the test
case stops running, the failure is recorded, and the next test case
runs.

   <p>So, you have to <em>turn checks into a Block evaluating to a Boolean,
and send the Block as the parameter to </em><code>#should:</code>.

   <p>In the example, after stimulating the fixture by adding an object to an
empty Set, we want to check and make sure it's in there:

<pre class="example">     SetTestCase&gt;&gt;#testAdd
         empty add: 5.
         self should: [empty includes: 5]
</pre>
   <p>There is a variant on
<code>TestCase&gt;&gt;#should:</code>. <code>TestCase&gt;&gt;#shouldnt:</code> causes the test
case to fail if the Block argument evaluates to true. It is there so you
don't have to use <code>(...) not</code>.

   <p>Once you have a test case this far, you can run it. Create an instance
of your TestCase subclass, giving it the selector of the testing
method. Send <code>run</code> to the resulting object:

<pre class="example">     (SetTestCase selector: #testAdd) run
</pre>
   <p>If it runs to completion, the test worked. If you get a walkback,
something went wrong.

<h4 class="subsection">3.7.4 How do you collect and run many different test cases?</h4>

<p>As soon as you have two test cases running, you'll want to run them both
one after the other without having to execute two do it's. You could
just string together a bunch of expressions to create and run test
cases. However, when you then wanted to run &ldquo;this bunch of cases and
that bunch of cases&rdquo; you'd be stuck.

   <p>The testing framework provides an object to represent <dfn>a bunch of
tests</dfn>, <code>TestSuite</code>. A <code>TestSuite</code> runs a collection of test
cases and reports their results all at once. Taking advantage of
polymorphism, <code>TestSuites</code> can also contain other
<code>TestSuites</code>, so you can put Joe's tests and Tammy's tests together
by creating a higher level suite.  <em>Combine test cases into a test
suite.</em>

<pre class="example">     (TestSuite named: 'Money')
         add: (MoneyTestCase selector: #testAdd);
         add: (MoneyTestCase selector: #testSubtract);
         run
</pre>
   <p>The result of sending <code>#run</code> to a <code>TestSuite</code> is a
<code>TestResult</code> object. It records all the test cases that caused
failures or errors, and the time at which the suite was run.

   <p>All of these objects are suitable for being stored in the image and
retrieved.  You can easily store a suite, then bring it in and run it,
comparing results with previous runs.

<h4 class="subsection">3.7.5 Running testsuites from the command line</h4>

<p><span class="sc">gnu</span> Smalltalk includes a Smalltalk script to simplify running SUnit test suites. 
It is called <samp><span class="command">gst-sunit</span></samp>.  The command-line to <samp><span class="command">gst-sunit</span></samp>
specifies the packages, files and classes to test:

     <dl>
<dt><samp><span class="option">-I</span></samp><dt><samp><span class="option">--image-file</span></samp><dd>Run tests inside the given image.

     <br><dt><samp><span class="option">-q</span></samp><dt><samp><span class="option">--quiet</span></samp><dd>Hide the program's output.  The results are still communicated with the
program's exit code.

     <br><dt><samp><span class="option">-v</span></samp><dt><samp><span class="option">--verbose</span></samp><dd>Be more verbose, in particular this will cause <samp><span class="command">gst-sunit</span></samp> to write
which test is currently being executed.

     <br><dt><samp><span class="option">-f </span><var>FILE</var></samp><dt><samp><span class="option">--file=</span><var>FILE</var></samp><dd>Load <var>FILE</var> before running the required test cases.

     <br><dt><samp><span class="option">-p </span><var>PACKAGE</var></samp><br><dt><samp><span class="option">--package=</span><var>PACKAGE</var></samp><dd>Load <var>PACKAGE</var> and its dependencies, and add <var>PACKAGE</var>'s tests to
the set of test cases to run.

     <br><dt><samp><var>CLASS</var></samp><dt><samp><var>CLASS</var><span class="option">*</span></samp><dd>Add <var>CLASS</var> to the set of test cases to run.  An asterisk after the class
name adds all the classes in <var>CLASS</var>'s hierarchy.  In particular,
each selector whose name starts with <code>test</code> constitutes a separate
test case.

     <br><dt><samp><var>VAR</var><span class="option">=</span><var>VALUE</var></samp><dd>Associate variable <var>VAR</var> with a value.  Variables allow customization
of the testing environment.  For example, the username with which to access
a database can be specified with variables.  From within a test, variables
are accessible with code like this:

     <pre class="example">              TestSuitesScripter variableAt: 'mysqluser' ifAbsent: [ 'root' ]
     </pre>
     <p>Note that a <code>#variableAt:</code> variant does <em>not</em> exist, because
the testsuite should pick default values in case the variables are
not specified by the user. 
</dl>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Extreme
   Programming is a software engineering technique that focuses on
   team work (to the point that a programmer looks in real-time at
   what another one is typing), frequent testing of the program,
   and incremental design.</p>

   <p><hr></div>

   </body></html>

