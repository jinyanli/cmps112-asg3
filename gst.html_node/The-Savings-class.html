<html lang="en">
<head>
<title>The Savings class - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Creating-subclasses.html#Creating-subclasses" title="Creating subclasses">
<link rel="next" href="The-Checking-class.html#The-Checking-class" title="The Checking class">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="The-Savings-class"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="The-Checking-class.html#The-Checking-class">The Checking class</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Creating-subclasses.html#Creating-subclasses">Creating subclasses</a>
<hr>
</div>

<h4 class="subsection">6.5.1 The Savings class</h4>

<p>We create the Savings class as a subclass of Account. 
It holds money, just like an Account, but has an additional
property that we will model: it is paid interest based on
its balance.  We create the class Savings as a subclass of
Account.
<pre class="example">        Account subclass: Savings [
            | interest |
</pre>
   <p>This is already telling something:
the instance variable <code>interest</code> will accumulate interest
paid.  Thus, in addition to the <code>spend:</code> and
<code>deposit:</code> messages which we inherit from our parent,
Account, we will need to define a method to add in interest
deposits, and a way to clear the interest variable (which
we would do yearly, after we have paid taxes).  We first define
a method for allocating a new account&mdash;we need to make sure that the
interest field starts at 0.

   <p>We can do so within the <code>Account subclass: Savings</code> scope,
which we have not closed above.
<pre class="example">        init [
            &lt;category: 'initialization'&gt;
            interest := 0.
            ^super init
        ]
</pre>
   <p>Recall that the parent took care of the <code>new</code> message, and
created a new object of the appropriate size.  After creation,
the parent also sent an <code>init</code> message to the new
object.  As a subclass of Account, the new object will
receive the <code>init</code> message first; it sets up its own
instance variable, and then passes the <code>init</code> message up the
chain to let its parent take care of its part of the
initialization.

   <p>With our new <code>Savings</code> account created, we can define
two methods for dealing specially with such an account:

<pre class="example">        interest: amount [
            interest := interest + amount.
            self deposit: amount
        ]
        clearInterest [
            | oldinterest |
            oldinterest := interest.
            interest := 0.
            ^oldinterest
        ]
</pre>
   <p>We are now finished, and close the class scope:

<pre class="example">     ]
</pre>
   <p>The first method says that we add the <code>amount</code> to our
running total of interest.  The line <code>self deposit: amount</code>
tells Smalltalk to send ourselves a message, in this case
<code>deposit: amount</code>.  This then causes Smalltalk to look up
the method for <code>deposit:</code>, which it finds in our parent,
Account.  Executing this method then updates our overall
balance.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

   <p>One may wonder why we don't just replace this with the
simpler <code>balance := balance + amount</code>.  The answer lies
in one of the philosophies of object-oriented languages in general,
and Smalltalk in particular.  Our goal is to encode a
technique for doing something once only, and then re-using
that technique when needed.  If we had directly encoded
<code>balance := balance + amount</code> here, there would have been
two places that knew how to update the balance from a
deposit.  This may seem like a useless difference.  But consider
if later we decided to start counting the number of
deposits made.  If we had encoded
<code>balance := balance + amount</code> in each place that needed to
update the balance, we would have to hunt each of them down in
order to update the count of deposits.  By sending <code>self</code>
the message <code>deposit:</code>, we need only update this method
once; each sender of this message would then automatically get the correct
up-to-date technique for updating the balance.

   <p>The second method, <code>clearInterest</code>, is simpler.  We
create a temporary variable <code>oldinterest</code> to hold the current
amount of interest.  We then zero out our interest to
start the year afresh.  Finally, we return the old interest
as our result, so that our year-end accountant can see how
much we made.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> <code>self</code> is much like <code>super</code>, except that
<code>self</code> will start looking for a method at the bottom
of the type hierarchy for the object, while
<code>super</code> starts looking one level up from the current
level.  Thus, using <code>super</code> forces inheritance,
but <code>self</code> will find the first definition
of the message which it can.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> Of course, in a real accounting system we
would never discard such information&mdash;we'd probably
throw it into a Dictionary object, indexed by the
year that we're finishing.  The ambitious might
want to try their hand at implementing such an
enhancement.</p>

   <p><hr></div>

   </body></html>

