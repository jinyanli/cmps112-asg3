<html lang="en">
<head>
<title>Smalltalk callin - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="C-and-Smalltalk.html#C-and-Smalltalk" title="C and Smalltalk">
<link rel="prev" href="Smalltalk-types.html#Smalltalk-types" title="Smalltalk types">
<link rel="next" href="Smalltalk-callbacks.html#Smalltalk-callbacks" title="Smalltalk callbacks">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Smalltalk-callin"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Smalltalk-callbacks.html#Smalltalk-callbacks">Smalltalk callbacks</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Smalltalk-types.html#Smalltalk-types">Smalltalk types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="C-and-Smalltalk.html#C-and-Smalltalk">C and Smalltalk</a>
<hr>
</div>

<h3 class="section">5.5 Calls from C to Smalltalk</h3>

<p><span class="sc">gnu</span> Smalltalk provides seven different function calls that allow you to call
Smalltalk methods in a different execution context than the current
one. The priority in which the method will execute will be the same as
the one of Smalltalk process which is currently active.

   <p>Four of these functions are more low level and are more suited when the
Smalltalk program itself gave a receiver, a selector and maybe some
parameters; the others, instead, are more versatile.  One of them
(<code>msgSendf</code>) automatically handles most conversions between C data
types and Smalltalk objects, while the others takes care of compiling full
snippets of Smalltalk code.

   <p>All these functions handle properly the case of specifying, say, 5 arguments
for a 3-argument selector&mdash;see the description of the single functions
for more information).

   <p>In all cases except <code>msgSendf</code>, passing NULL as the selector will
expect the receiver to be a block and evaluate it.

<div class="defun">
&mdash; Function: OOP <b>msgSend</b> (<var>OOP receiver, OOP selector, <small class="dots">...</small></var>)<var><a name="index-msgSend-70"></a></var><br>
<blockquote><p>This function sends the given selector (should be a Symbol, otherwise
<code>nilOOP</code> is returned) to the given receiver.  The message arguments should
also be OOPs (otherwise, an access violation exception is pretty likely)
and are passed in a NULL-terminated list after the selector.  The value
returned from the method is passed back as an OOP to the C program as
the result of <code>msgSend</code>, or <code>nilOOP</code> if the number of arguments is
wrong.  Example (same as <code>1 + 2</code>):

     <pre class="example">              OOP shouldBeThreeOOP = vmProxy-&gt;msgSend(
                  intToOOP(1),
                  symbolToOOP("+"),
                  intToOOP(2),
                  NULL);
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>strMsgSend</b> (<var>OOP receiver, char *selector, <small class="dots">...</small></var>)<var><a name="index-strMsgSend-71"></a></var><br>
<blockquote><p>This function is the same as above, but the selector is passed as a C
string and is automatically converted to a Smalltalk symbol.

        <p>Theoretically, this function is a bit slower than <code>msgSend</code> if your
program has some way to cache the selector and avoiding a call to
<code>symbolToOOP</code> on every call-in.  However, this is not so apparent
in &ldquo;real&rdquo; code because the time spent in the Smalltalk interpreter
will usually be much higher than the time spent converting the selector
to a Symbol object.  Example:

     <pre class="example">              OOP shouldBeThreeOOP = vmProxy-&gt;strMsgSend(
                  intToOOP(1),
                  "+",
                  intToOOP(2),
                  NULL);
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>vmsgSend</b> (<var>OOP receiver, OOP selector, OOP *args</var>)<var><a name="index-vmsgSend-72"></a></var><br>
<blockquote><p>This function is the same as msgSend, but accepts a pointer to the
NULL-terminated list of arguments, instead of being a variable-arguments
functions.  Example:

     <pre class="example">              OOP arguments[2], shouldBeThreeOOP;
              arguments[0] = intToOOP(2);
              arguments[1] = NULL;
              /* ... some more code here ... */
          
              shouldBeThreeOOP = vmProxy-&gt;vmsgSend(
                  intToOOP(1),
                  symbolToOOP("+"),
                  arguments);
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>nvmsgSend</b> (<var>OOP receiver, OOP selector, OOP *args, int nargs</var>)<var><a name="index-nvmsgSend-73"></a></var><br>
<blockquote><p>This function is the same as msgSend, but accepts an additional parameter
containing the number of arguments to be passed to the Smalltalk method,
instead of relying on the NULL-termination of args.  Example:

     <pre class="example">              OOP argument, shouldBeThreeOOP;
              argument = intToOOP(2);
              /* ... some more code here ... */
          
              shouldBeThreeOOP = vmProxy-&gt;nvmsgSend(
                  intToOOP(1),
                  symbolToOOP("+"),
                  &amp;argument,
                  1);
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>perform</b> (<var>OOP, OOP</var>)<var><a name="index-perform-74"></a></var><br>
<blockquote><p>Shortcut function to invoke a unary selector.  The first parameter
is the receiver, and the second is the selector. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>performWith</b> (<var>OOP, OOP, OOP</var>)<var><a name="index-performWith-75"></a></var><br>
<blockquote><p>Shortcut function to invoke a one-argument selector.  The first parameter
is the receiver, the second is the selector, the third is the sole
argument. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>invokeHook</b> (<var>int</var>)<var><a name="index-invokeHook-76"></a></var><br>
<blockquote><p>Calls into Smalltalk to process a <code>ObjectMemory</code> hook given by
the parameter.  In practice, <code>changed:</code> is sent to <code>ObjectMemory</code>
with a symbol derived from the parameter.  The parameter can be one of:
          <ul>
<li><code>GST_BEFORE_EVAL</code>
<li><code>GST_AFTER_EVAL</code>
<li><code>GST_ABOUT_TO_QUIT</code>
<li><code>GST_RETURN_FROM_SNAPSHOT</code>
<li><code>GST_ABOUT_TO_SNAPSHOT</code>
<li><code>GST_FINISHED_SNAPSHOT</code>
</ul>

        <p>All cases where the last three should be used should be covered in
<span class="sc">gnu</span> Smalltalk's source code.  The first three, however, can actually be useful
in user code. 
</p></blockquote></div>

   <p>The two functions that directly accept Smalltalk code are named
<code>evalCode</code> and <code>evalExpr</code>, and they're basically the same. 
They both accept a single parameter, a pointer to the code to be
submitted to the parser.  The main difference is that <code>evalCode</code>
discards the result, while <code>evalExpr</code> returns it to the caller
as an OOP.

   <p><code>msgSendf</code>, instead, has a radically different syntax. Let's first
look at some examples.

<pre class="example">         /* 1 + 2 */
         int shouldBeThree;
         vmProxy-&gt;msgSendf(&amp;shouldBeThree, "%i %i + %i", 1, 2)
     
         /* aCollection includes: 'abc' */
         OOP aCollection;
         int aBoolean;
         vmProxy-&gt;msgSendf(&amp;aBoolean, "%b %o includes: %s", aCollection, "abc")
     
         /* 'This is a test' printNl -- in two different ways */
         vmProxy-&gt;msgSendf(NULL, "%v %s printNl", "This is a test");
         vmProxy-&gt;msgSendf(NULL, "%s %s printNl", "This is a test");
     
         /* 'This is a test', ' ok?' */
         char *str;
         vmProxy-&gt;msgSendf(&amp;str, "%s %s , %s", "This is a test", " ok?");
</pre>
   <p>As you can see, the parameters to msgSendf are, in order:

     <ul>
<li>A pointer to the variable which will contain the record. If this pointer
is <code>NULL</code>, it is discarded.

     <li>A description of the method's interface in this format (the object
types, after percent signs, will be explained later in this section)

     <pre class="example">          %result_type %receiver_type selector %param1_type %param2_type
     </pre>
     <li>A C variable or Smalltalk object (depending on the type specifier) for
the receiver

     <li>If needed, The C variables and/or Smalltalk object (depending on the
type specifiers) for the arguments. 
</ul>

   <p>Note that the receiver and parameters are NOT registered in the object
registry (see <a href="Smalltalk-types.html#Smalltalk-types">Smalltalk types</a>).  <dfn>receiver_type</dfn> and
<dfn>paramX_type</dfn> can be any of these characters, with these meanings:

<pre class="example">           Specifier        C data type        equivalent Smalltalk class
               i                long           Integer (see intToOOP)
               f               double          Float (see floatToOOP)
               F            long double        Float (see longDoubleToOOP)
               b                int            True or False (see boolToOOP)
               B                OOP            BlockClosure
               c                char           Character (see charToOOP)
               C               PTR             CObject (see cObjToOOP)
               s               char *          String (see stringToOOP)
               S               char *          Symbol (see symbolToOOP)
               o                OOP            any
               t            char *, PTR        CObject (see below)
               T              OOP, PTR         CObject (see below)
               w              wchar_t          Character (see wcharToOOP)
               W             wchar_t *         UnicodeString (see wstringToOOP)
</pre>
   <p class="noindent">`<samp><span class="samp">%t</span></samp>' and `<samp><span class="samp">%T</span></samp>' are particular in the sense that you need to
pass <dfn>two</dfn> additional arguments to <code>msgSendf</code>, not one.  The
first will be a description of the type of the CObject to be created,
the second instead will be the CObject's address.  If you specify
`<samp><span class="samp">%t</span></samp>', the first of the two arguments will be converted to a
Smalltalk <code>CType</code> via <code>typeNameToOOP</code> (see <a href="Smalltalk-types.html#Smalltalk-types">Smalltalk types</a>); instead, if you specify `<samp><span class="samp">%T</span></samp>', you will have to directly
pass an OOP for the new CObject's type.

   <p>For `<samp><span class="samp">%B</span></samp>' you should not pass a selector, and the block will be
evaluated.

   <p>The type specifiers you can pass for <dfn>result_type</dfn> are a bit
different:

<pre class="example">                 Result
     Specifier   if nil    C data type      expected result
        i         0L          long          nil or an Integer
        f         0.0        double         nil or a Float
        F         0.0     long double       nil or a Float
        b          0          int           nil or a Boolean
        c        '\0'         char          nil or a Character
        C        NULL        PTR            nil or a CObject
        s        NULL        char *         nil, a String, or a Symbol
        ?         0      char *, PTR        See oopToC
        o       nilOOP        OOP           any (result is not converted)
        w        '\0'       wchar_t         nil or a Character
        W        NULL      wchar_t *        nil or a UnicodeString
        v                      /            any (result is discarded)
</pre>
   <p>Note that, if resultPtr is <code>NULL</code>, the <dfn>result_type</dfn> is always
treated as `<samp><span class="samp">%v</span></samp>'.  If an error occurs, the value in the `result if
nil' column is returned.

   </body></html>

