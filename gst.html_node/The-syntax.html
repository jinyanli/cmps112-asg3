<html lang="en">
<head>
<title>The syntax - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tutorial.html#Tutorial" title="Tutorial">
<link rel="prev" href="And-now.html#And-now" title="And now">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="The-syntax"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="And-now.html#And-now">And now</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tutorial.html#Tutorial">Tutorial</a>
<hr>
</div>

<h3 class="section">6.14 A Simple Overview of Smalltalk Syntax</h3>

<p>Smalltalk's power comes from its treatment of objects. 
In this document, we've mostly avoided the issue of syntax
by using strictly parenthesized expressions as needed.  When
this leads to code which is hard to read due to the density
of parentheses, a knowledge of Smalltalk's syntax can let
you simplify expressions.  In general, if it was hard for
you to tell how an expression would parse, it will be hard
for the next person, too.

   <p>The following presentation presents the grammar a couple
of related elements at a time.  We use an EBNF style of
grammar.  The form:
<pre class="example">        [ ...  ]
</pre>
   <p class="noindent">means that &ldquo;<small class="dots">...</small>&rdquo; can occur zero or one times.

<pre class="example">        [ ...  ]*
</pre>
   <p class="noindent">means zero or more;

<pre class="example">        [ ...  ]+
</pre>
   <p class="noindent">means one or more.

<pre class="example">        ...  | ...  [ | ...  ]*
</pre>
   <p class="noindent">means that one of the variants must be chosen.  Characters
in double quotes refer to the literal characters.  Most elements
may be separated by white space; where this is not legal, the
elements are presented without white space
between them.

     <dl>
<dt><tt>methods: &ldquo;!&rdquo; id [&ldquo;class&rdquo;] &ldquo;methodsFor:&rdquo; string &ldquo;!&rdquo; [method &ldquo;!&rdquo;] &ldquo;!&rdquo;</tt><dd>Methods are introduced by first naming a class (the id element),
specifying &ldquo;class&rdquo; if you're adding class methods
instead of instance methods, and sending a string argument
to the methodsFor: message.  Each method is terminated with
an &ldquo;!&rdquo;; two bangs in a row (with a space in the middle)
signify the end of the new methods.

     <br><dt><tt>method: message [pragma] [temps] exprs</tt><dt><tt>message: id | binsel id | [keysel id]+</tt><dt><tt>pragma: &ldquo;&lt;&rdquo; keymsg &ldquo;&gt;&rdquo;</tt><dt><tt>temps: &ldquo;|&rdquo; [id]* &ldquo;|&rdquo;</tt><dd>A method definition starts out with a kind of template.  The
message to be handled is specified with the message names
spelled out and identifiers in the place of arguments.  A
special kind of definition is the pragma; it has not been
covered in this tutorial and it provides a way to mark a
method specially as well as the interface to the underlying
Smalltalk virtual machine.  temps is the declaration
of local variables.  Finally, exprs (covered soon) is
the actual code for implementing the method.

     <br><dt><tt>unit: id | literal | block | arrayconstructor | &ldquo;(&rdquo; expr &ldquo;)&rdquo;</tt><dt><tt>unaryexpr: unit [ id ]+</tt><dt><tt>primary: unit | unaryexpr</tt><dd>These are the &ldquo;building blocks&rdquo; of Smalltalk expressions.  A
unit represents a single Smalltalk value, with the highest
syntactic precedence.  A unaryexpr is simply a unit which
receives a number of unary messages.  A unaryexpr has the
next highest precedence.  A primary is simply a convenient
left-hand-side name for one of the above.

     <br><dt><tt>exprs: [expr &ldquo;.&rdquo;]* [[&ldquo;^&rdquo;] expr]</tt><dt><tt>expr: [id &ldquo;:=&rdquo;]* expr2</tt><b> <br></b><dt><tt>expr2: primary | msgexpr [ &ldquo;;&rdquo; cascade ]*</tt><dd>A sequence of expressions is separated by dots and can end
with a returned value (<code>^</code>).  There can be leading assignments;
unlike C, assignments apply only to simple variable names.  An
expression is either a primary (with highest precedence) or
a more complex message.  cascade does not apply to primary
constructions, as they are too simple to require the construct. 
Since all primary construct are unary, you can just add more unary messages:
     <pre class="example">             1234 printNl printNl printNl
     </pre>
     <br><dt><tt>msgexpr: unaryexpr | binexpr | keyexpr</tt><dd>A complex message is either a unary message (which we have
already covered), a binary message (<code>+</code>, <code>-</code>, and so forth),
or a keyword message (<code>at:</code>, <code>new:</code>, <small class="dots">...</small>) Unary has the
highest precedence, followed by binary, and keyword messages
have the lowest precedence.  Examine the two versions of the
following messages.  The second have had parentheses added
to show the default precedence.
     <pre class="example">             myvar at: 2 + 3 put: 4
             mybool ifTrue: [ ^ 2 / 4 roundup ]
          
             (myvar at: (2 + 3) put: (4))
             (mybool ifTrue: ([ ^ (2 / (4 roundup)) ]))
     </pre>
     <br><dt><tt>cascade: id | binmsg | keymsg</tt><dd>A cascade is used to direct further messages to the same
object which was last used.  The three types of messages (
id is how you send a unary message) can thus be sent.

     <br><dt><tt>binexpr: primary binmsg [ binmsg ]*</tt><dt><tt>binmsg: binsel primary</tt><dt><tt>binsel: binchar[binchar]</tt><dd>A binary message is sent to an object, which primary has
identified.  Each binary message is a binary selector, constructed
from one or two characters, and an argument which
is also provided by a primary.
     <pre class="example">             1 + 2 - 3 / 4
     </pre>
     <p class="noindent">which parses as:
     <pre class="example">             (((1 + 2) - 3) / 4)
     </pre>
     <br><dt><tt>keyexpr: keyexpr2 keymsg</tt><dt><tt>keyexpr2: binexpr | primary</tt><dt><tt>keymsg: [keysel keyw2]+</tt><dt><tt>keysel: id&ldquo;:&rdquo;</tt><dd>Keyword expressions are much like binary expressions, except
that the selectors are made up of identifiers with a colon
appended.  Where the arguments to a binary function can only
be from primary, the arguments to a keyword can be binary
expressions or primary ones.  This is because keywords have
the lowest precedence.

     <br><dt><tt>block: &ldquo;[&rdquo; [[&ldquo;:&rdquo; id]* &ldquo;|&rdquo; ] [temps] exprs &ldquo;]&rdquo;</tt><dd>A code block is square brackets around a collection of
Smalltalk expressions.  The leading &ldquo;: id&rdquo; part is for block
arguments.  Note that it is possible for a block to have
temporary variables of its own.

     <br><dt><tt>arrayconstructor: &ldquo;{&rdquo; exprs &ldquo;}&rdquo;</tt><dd>Not covered in this tutorial, this syntax allows to create
arrays whose values are not literals, but are instead evaluated
at run-time.  Compare <code>#(a b)</code>, which results in an Array
of two symbols <code>#a</code> and <code>#b</code>, to <code>{a. b+c}</code> which
results in an Array whose two elements are the contents of variable
<code>a</code> and the result of summing <code>c</code> to <code>b</code>.

     <br><dt><tt>literal: number | string | charconst | symconst | arrayconst | binding | eval</tt><dt><tt>arrayconst: &ldquo;#&rdquo; array | &ldquo;#&rdquo; bytearray</tt><dt><tt>bytearray: &ldquo;[&rdquo; [number]* &ldquo;]&rdquo;</tt><dt><tt>array: &ldquo;(&rdquo; [literal | array | bytearray | arraysym | ]* &ldquo;)&rdquo;</tt><dt><tt>number: [[dig]+ &ldquo;r&rdquo;] [&ldquo;-&rdquo;] [alphanum]+ [&ldquo;.&rdquo; [alphanum]+] [exp [&ldquo;-&rdquo;][dig]+].</tt><dt><tt>string: "'"[char]*"'"</tt><dt><tt>charconst: &ldquo;$&rdquo;char</tt><dt><tt>symconst: &ldquo;#&rdquo;symbol | &ldquo;#&rdquo;string </tt><dt><tt>arraysym: [id | &ldquo;:&rdquo;]*</tt><dt><tt>exp: &ldquo;d&rdquo; | &ldquo;e&rdquo; | &ldquo;q&rdquo; | &ldquo;s&rdquo;</tt><dd>We have already shown the use of many of these constants. 
Although not covered in this tutorial, numbers can have a base
specified at their front, and a trailing scientific notation. 
We have seen examples of character, string, and symbol constants. 
Array constants are simple enough; they would look like:
     <pre class="example">             a := #(1 2 'Hi' $x #Hello 4 16r3F)
     </pre>
     <p>There are also ByteArray constants, whose elements are constrained
to be integers between 0 and 255; they would look like:
     <pre class="example">             a := #[1 2 34 16r8F 26r3H 253]
     </pre>
     <p>Finally, there are three types of floating-point constants with
varying precision (the one with the <code>e</code> being the less
precise, followed by <code>d</code> and <code>q</code>), and scaled-decimal
constants for a special class which does exact computations but
truncates comparisons to a given number of decimals.  For example,
<code>1.23s4</code> means &ldquo;the value <code>1.23</code>, with four significant
decimal digits&rdquo;.

     <br><dt><tt>binding: &ldquo;#{&rdquo; [id &ldquo;.&rdquo;]* id &ldquo;}&rdquo;</tt><dd>This syntax has not been used in the tutorial, and results in an
Association literal (known as a <dfn>variable binding</dfn>) tied to
the class that is named between braces.  For example,
<code>#{Class} value</code> is the same as <code>Class</code>.  The
dot syntax is required for supporting namespaces:
<code>#{Smalltalk.Class}</code> is the same as
<code>Smalltalk associationAt: #Class</code>, but is resolved
at compile-time rather than at run-time.

     <br><dt><tt>symbol: id | binsel | keysel[keysel]*</tt><dd>Symbols are mostly used to represent the names of methods. 
Thus, they can hold simple identifiers, binary selectors,
and keyword selectors:
     <pre class="example">             #hello
             #+
             #at:put:
     </pre>
     <dt><tt>eval: &ldquo;#&rdquo; &ldquo;#&rdquo; &ldquo;(&rdquo; [temps] exprs &ldquo;)&rdquo;</tt><dd>This syntax also has not been used in the tutorial, and results
in evaluating an arbitrarily complex expression at compile-time,
and substituting the result: for example <code>##(Object allInstances
size)</code> is the number of instances of <code>Object</code> held in the
image <em>at the time the method is compiled</em>.

     <br><dt><tt>id: letter[letter|dig]*</tt><dt><tt>binchar: &ldquo;+&rdquo; | &ldquo;-&rdquo; | &ldquo;*&rdquo; | &ldquo;/&rdquo; | &ldquo;~&rdquo; | &ldquo;|&rdquo; | &ldquo;,&rdquo; |</tt><dt><tt>&ldquo;&lt;&rdquo; | &ldquo;&gt;&rdquo; | &ldquo;=&rdquo; | &ldquo;&amp;&rdquo; | &ldquo;&acute;' | &ldquo;?&rdquo; | &ldquo;\&rdquo; | &ldquo;%&rdquo;</tt><dt><tt>alphanum: &ldquo;0&rdquo;..&ldquo;9&rdquo; | &ldquo;A&rdquo;..&ldquo;Z&rdquo;</tt><dt><tt>dig: &ldquo;0&rdquo;..&ldquo;9&rdquo;</tt><dd>These are the categories of characters and how they are combined
at the most basic level.  binchar simply lists the
characters which can be combined to name a binary message.

   </dl>

</body></html>

