<html lang="en">
<head>
<title>Namespaces - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Features.html#Features" title="Features">
<link rel="prev" href="Regular-expressions.html#Regular-expressions" title="Regular expressions">
<link rel="next" href="Disk-file_002dIO.html#Disk-file_002dIO" title="Disk file-IO">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Namespaces"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Disk-file_002dIO.html#Disk-file_002dIO">Disk file-IO</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Regular-expressions.html#Regular-expressions">Regular expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Features.html#Features">Features</a>
<hr>
</div>

<h3 class="section">2.3 Namespaces</h3>

<p><i>[This section (and the implementation of namespaces in </i><span class="sc">gnu</span><i> Smalltalk)
is based on the paper </i><cite>Structured Symbolic Name Spaces in
Smalltalk</cite><i>, by Augustin Mrazik.]</i>

<h4 class="subsection">2.3.1 Introduction</h4>

<p>The Smalltalk-80 programming environment, upon which <span class="sc">gnu</span> Smalltalk is
historically based, supports symbolic identification of objects in one
global namespace&mdash;in the <code>Smalltalk</code> system dictionary. This means
that each global variable in the system has its unique name which is
used for symbolic identification of the particular object in the source
code (e.g. in expressions or methods).  The most important of these
global variables are classes defining the behavior of objects.

   <p>In development dealing with modelling of real systems, <dfn>polymorphic
symbolic identification</dfn> is often needed.  By this, we mean that it
should be possible to use the same name for different classes or other
global variables.  Selection of the proper variable binding should be
context-specific.  By way of illustration, let us consider class
<code>Statement</code> as an example which would mean totally different things
in different domains:

     <dl>
<dt><span class="sc">gnu</span> Smalltalk or other programming language<dd>An expression in the top level of a code body, possibly with special
syntax available such as assignment or branching.

     <br><dt>Bank<dd>A customer's trace report of recent transactions.

     <br><dt>AI, logical derivation<dd>An assertion of a truth within a logical system. 
</dl>

   <p>This issue becomes inevitable if we start to work persistently, using
<code>ObjectMemory snapshot</code> to save after each session for later
resumption.  For example, you might have the class <code>Statement</code>
already in your image with the &ldquo;Bank&rdquo; meaning above (e.g. in the
live bank support systems we all run in our images) and you might decide
to start developing <acronym>YAC</acronym> [Yet Another C].  Upon starting to
write parse nodes for the compiler, you would find that
<code>#Statement</code> is boundk in the banking package.  You could replace
it with your parse node class, and the bank's <code>Statement</code> could
remain in the system as an unbound class with full functionality;
however, it could not be accessed anymore at the symbolic level in the
source code.  Whether this would be a problem or not would depend on
whether any of the bank's code refers to the class <code>Statement</code>, and
when these references occur.

   <p>Objects which have to be identified in source code by their names are
included in <code>Smalltalk</code>, the sole instance of
<code>SystemDictionary</code>.  Such objects may be identified simply by
writing their names as you would any variable names.  The code is
compiled in the default environment, and if the variable is found in
<code>Smalltalk</code>, without being shadowed by a class pool or local
variables, its value is retrieved and used as the value of the
expression.  In this way <code>Smalltalk</code> represents the sole symbolic
namespace.  In the following text the symbolic namespace, as a concept,
will be called simply <dfn>environment</dfn> to make the text more clear.

<h4 class="subsection">2.3.2 Concepts</h4>

<p>To support polymorphic symbolical identification several environments
will be needed.  The same name may exist concurrently in several
environments as a key, pointing to diverse objects in each.

   <p>Symbolic navigation between these environments is needed.  Before
approaching the problem of the syntax and semantics to be implemented,
we have to decide on structural relations to be established between
environments.

   <p>Since the environment must first be symbolically identified to direct
access to its global variables, it must first itself be a global
variable in another environment.  <code>Smalltalk</code> is a great choice for
the root environment, from which selection of other environments and
their variables begins. From <code>Smalltalk</code> some of the existing
sub-environments may be seen; from these other sub-environments may be
seen, etc.  This means that environments represent nodes in a graph
where symbolic selections from one environment to another one represent
branches.

   <p>The symbolic identification should be unambiguous, although it will be
polymorphic. This is why we should avoid cycles in the environment
graph. Cycles in the graph could cause also other problems in the
implementation, e.g. inability to use trivially recursive algorithms. 
Thus, in general, the environments must build a directed acyclic graph;
<span class="sc">gnu</span> Smalltalk currently limits this to an n-ary tree, with the extra feature
that environments can be used as pool dictionaries.

   <p>Let us call the partial ordering relation which occurs between
environments <dfn>inheritance</dfn>.  Sub-environments inherit from their
super-environments.  The feature of inheritance in the meaning of
object-orientation is associated with this relation: all associations of
the super-environment are valid also in its sub-environments, unless they
are locally redefined in the sub-environment.

   <p>A super-environment includes all its sub-enviroments as
<code>Association</code>s under their names.  The sub-environment includes its
super-environment under the symbol <code>#Super</code>.  Most environments
inherit from <code>Smalltalk</code>, the standard root environment, but they
are not required to do so; this is similar to how most classes derive
from <code>Object</code>, yet one can derive a class directly from <code>nil</code>. 
Since they all inherit <code>Smalltalk</code>'s global variables, it is not
necessary to define <code>Smalltalk</code> as pointing to <code>Smalltalk</code>'s
<code>Smalltalk</code> in each environment.

   <p>The inheritance links to the super-environments are used in the lookup
for a potentially inherited global variable.  This includes lookups by a
compiler searching for a variable binding and lookups via methods such
as <code>#at:</code> and <code>#includesKey:</code>.

<h4 class="subsection">2.3.3 Syntax</h4>

<p>Global objects of an environment, be they local or inherited, may be
referenced by their symbol variable names used in the source code, e.g.
<pre class="example">                 John goHome
</pre>
   <p class="noindent">if the <code>#John -&gt; aMan</code> association exists in the particular environment or
one of its super-environments, all along the way to the root environment.

   <p>If an object must be referenced from another environment (i.e. which
is not one of its sub-environments) it has to be referenced either
<em>relatively</em> to the position of the current environment, using the
<code>Super</code> symbol, or <em>absolutely</em>, using the &ldquo;full pathname&rdquo;
of the object, navigating from the tree root (usually <code>Smalltalk</code>)
through the tree of sub-environments.

   <p>For the identification of global objects in another environment, we use
a &ldquo;pathname&rdquo; of symbols.  The symbols are separated by periods; the
&ldquo;look&rdquo; to appear is that of
<pre class="example">     Smalltalk.Tasks.MyTask
</pre>
   <p class="noindent">and of
<pre class="example">     Super.Super.Peter.
</pre>
   <p>As is custom in Smalltalk, we are reminded by capitalization that we
are accessing global objects.  Another syntax returns the <dfn>variable
binding</dfn>, the <code>Association</code> for a particular global.  The first
example above is equivalently:
<pre class="example">     #{Smalltalk.Tasks.MyTask} value
</pre>
   <p>The latter syntax, a <dfn>variable binding</dfn>, is also valid inside
literal arrays.

<h4 class="subsection">2.3.4 Implementation</h4>

<p>A superclass of <code>SystemDictionary</code> called <code>RootNamespace</code> is
defined, and many of the features of the Smalltalk-80
<code>SystemDictionary</code> will be hosted by that class.  <code>Namespace</code>
and <code>RootNamespace</code> are in turn subclasses of
<code>AbstractNamespace</code>.

   <p>To handle inheritance, the following methods have to be defined or redefined in
Namespace (<em>not</em> in RootNamespace):

     <dl>
<dt>Accessors like <code>#at:ifAbsent:</code> and <code>#includesKey:</code><dd>Inheritance must be implemented.  When <code>Namespace</code>, trying to read
a variable, finds an association in its own dictionary or a
super-environment dictionary, it uses that; for <code>Dictionary</code>'s
writes and when a new association must be created, <code>Namespace</code>
creates it in its own dictionary.  There are special methods like
<code>#set:to:</code> for cases in which you want to modify a binding in a
super-environment if that is the relevant variable's binding.

     <!-- this needs more clarity for #at:put: #set:to: disambig -->
<br><dt>Enumerators like <code>#do:</code> and <code>#keys</code><dd>This should return <strong>all</strong> the objects in the namespace, including
those which are inherited.

     <br><dt>Hierarchy access<dd><code>AbstractNamespace</code> will also implement a new set of
methods that allow one to navigate through the namespace hierarchy;
these parallel those found in <code>Behavior</code> for the class hierarchy. 
</dl>

   <p>The most important task of the <code>Namespace</code> class is to provide
organization for the most important global objects in the Smalltalk
system&mdash;for the classes.  This importance becomes even more crucial in
a structure of multiple environments intended to change the semantics of
code compiled for those classes.

   <p>In Smalltalk the classes have the instance variable <code>name</code> which
holds the name of the class. Each <dfn>defined class</dfn> is included in
<code>Smalltalk</code>, or another environment, under this name.  In a
framework with several environments the class should know the
environment in which it has been created and compiled.  This is a new
property of <code>Class</code> which must be defined and properly used in
relevant methods.  In the mother environment the class shall be included
under its name.

   <p>Any class, as with any other object, may be included concurrently in
several environments, even under different symbols in the same or in
diverse environments.  We can consider these &ldquo;alias names&rdquo; of the
particular class or other value.  A class may be referenced under the
other names or in other environments than its mother environment, e.g. 
for the purpose of instance creation or messages to the class, but it
should not compile code in these environments, even if this compilation
is requested from another environment.  If the syntax is not correct in
the mother environment, a compilation error occurs.  This follows from
the existence of class &ldquo;mother environments&rdquo;, as a class is
responsible for compiling its own methods.

   <p>An important issue is also the name of the class answered by the class
for the purpose of its identification in diverse tools (e.g. in a
browser). This must be changed to reflect the environment in which it is
shown, i.e. the method `<samp><span class="samp">nameIn: environment</span></samp>' must be implemented
and used in proper places.

   <p>Other changes must be made to the Smalltalk system to achieve the full
functionality of structured environments.  In particular, changes have
to be made to the behavior classes, the user interface, the compiler,
and a few classes supporting persistance.  One small detail of note is
that evaluation in the <acronym>REPL</acronym> or `<samp><span class="samp">Workspace</span></samp>', implemented
by compiling methods on <code>UndefinedObject</code>, make more sense if
<code>UndefinedObject</code>'s environment is the &ldquo;current environment&rdquo; as
reachable by <code>Namespace current</code>, even though its mother
environment by any other sensibility is <code>Smalltalk</code>.

<h4 class="subsection">2.3.5 Using namespaces</h4>

<p>Using namespaces is often merely a matter of adding a `<samp><span class="samp">namespace</span></samp>'
option to the <span class="sc">gnu</span> Smalltalk <acronym>XML</acronym> package description used by
<code>PackageLoader</code>, or wrapping your code like this:
<pre class="example">         Namespace current: NewNS [
             <span class="roman">...</span>
         ]
</pre>
   <p>Namespaces can be imported into classes like this:
<pre class="example">         Stream subclass: EncodedStream [
             &lt;import: Encoders&gt;
         ]
</pre>
   <p class="noindent">Alternatively, paths to
classes (and other objects) in the namespaces will have to be specified
completely.  Importing a namespace into a class is similar to C++'s
<code>using namespace</code> declaration within the class proper's definition.

   <p>Finally, be careful when working with fundamental system classes.  Although you
can use code like
<pre class="example">         Namespace current: NewNS [
             Smalltalk.Set subclass: #Set [
                 &lt;category: 'My application-Extensions'&gt;
                 <span class="roman">...</span>
             ]
         ]
</pre>
   <p class="noindent">this approach won't work
when applied to core classes.  For example, you might be successful with
a <code>Set</code> or <code>WriteStream</code> object, but subclassing
<code>SmallInteger</code> this way can bite you in strange ways: integer
literals will still belong to the <code>Smalltalk</code> dictionary's version
of the class (this holds for <code>Array</code>s, <code>String</code>s, etc. too),
primitive operations will still answer standard Smalltalk
<code>SmallIntegers</code>, and so on.  Similarly,
word-shaped will recognize 32-bit <code>Smalltalk.LargeInteger</code> objects,
but not <code>LargeInteger</code>s belonging to your own namespace.

   <p>Unfortunately, this problem is not easy to solve since Smalltalk has to
know the <acronym>OOP</acronym>s of determinate class objects for speed&mdash;it
would not be feasible to lookup the environment to which sender of a
message belongs every time the <code>+</code> message was sent to an Integer.

   <p>So, <span class="sc">gnu</span> Smalltalk namespaces cannot yet solve 100% of the problem of clashes
between extensions to a class&mdash;for that you'll still have to rely on
prefixes to method names.  But they <em>do</em> solve the problem of clashes
between class names, or between class names and pool dictionary names.

   <p>Namespaces are unrelated from packages; loading a package does not
import the corresponding namespace.

   </body></html>

