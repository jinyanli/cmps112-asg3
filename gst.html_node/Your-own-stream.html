<html lang="en">
<head>
<title>Your own stream - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Streams.html#Streams" title="Streams">
<link rel="prev" href="The-output-stream.html#The-output-stream" title="The output stream">
<link rel="next" href="Files.html#Files" title="Files">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Your-own-stream"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Files.html#Files">Files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="The-output-stream.html#The-output-stream">The output stream</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Streams.html#Streams">Streams</a>
<hr>
</div>

<h4 class="subsection">6.10.2 Your Own Stream</h4>

<p>Unlike a pipe you might create in C, the underlying
storage of a Stream is under your control.  Thus, a Stream
can provide an anonymous buffer of data, but it can also
provide a stream-like interpretation to an existing array of
data.  Consider this example:
<pre class="example">        a := Array new: 10
        a at: 4 put: 1234
        a at: 9 put: 5678
        s := ReadWriteStream on: a.
        s inspect
        s position: 1
        s inspect
        s nextPut: 11; nextPut: 22
        (a at: 1) printNl
        a do: [:x| x printNl]
        s position: 2
        s do: [:x| x printNl]
        s position: 5
        s do: [:x| x printNl]
        s inspect
</pre>
   <p>The key is the <code>on:</code> message; it tells a stream class to
create itself in terms of the existing storage.  Because of
polymorphism, the object specified by on: does not have to
be an Array; any object which responds to numeric at: messages
can be used.  If you happen to have the NiledArray
class still loaded from the previous chapter, you might try
streaming over that kind of array instead.

   <p>You're wondering if you're stuck with having to know
how much data will be queued in a Stream at the time you
create the stream.  If you use the right class of stream,
the answer is no.  A ReadStream provides read-only access to
an existing collection.  You will receive an error if you
try to write to it.  If you try to read off the end of the
stream, you will also get an error.

   <p>By contrast, WriteStream and ReadWriteStream (used in
our example) will tell the underlying collection to grow
when you write off the end of the existing collection.  Thus,
if you want to write several strings, and don't want to add up their
lengths yourself:

<pre class="example">        s := ReadWriteStream on: String new
        s inspect
        s nextPutAll: 'Hello, '
        s inspect
        s nextPutAll: 'world'
        s inspect
        s position: 1
        s inspect
        s do: [:c | stdout nextPut: c ]
        s contents
</pre>
   <p>In this case, we have used a String as the collection
for the Stream.  The <code>printOn:</code> messages add bytes to the initially
empty string.  Once we've added the data, you can
continue to treat the data as a stream.  Alternatively, you
can ask the stream to return to you the underlying object. 
After that, you can use the object (a String, in this example)
using its own access methods.

   <p>There are many amenities available on a stream object. 
You can ask if there's more to read with <code>atEnd</code>.  You can
query the position with <code>position</code>, and set it with <code>position:</code>. 
You can see what will be read next with <code>peek</code>, and
you can read the next element with <code>next</code>.

   <p>In the writing direction, you can write an element with
<code>nextPut:</code>.  You don't need to worry about objects doing a
<code>printOn:</code> with your stream as a destination; this operation
ends up as a sequence of <code>nextPut:</code> operations to your stream. 
If you have a collection of things to write, you can use
<code>nextPutAll:</code> with the collection as an argument; each member
of the collection will be written onto the stream.  If you
want to write an object to the stream several times, you
can use <code>next:put:</code>, like this:

<pre class="example">        s := ReadWriteStream on: (Array new: 0)
        s next: 4 put: 'Hi!'
        s position: 1
        s do: [:x | x printNl]
</pre>
   </body></html>

