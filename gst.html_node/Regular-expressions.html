<html lang="en">
<head>
<title>Regular expressions - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Features.html#Features" title="Features">
<link rel="prev" href="Extended-streams.html#Extended-streams" title="Extended streams">
<link rel="next" href="Namespaces.html#Namespaces" title="Namespaces">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Regular-expressions"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Namespaces.html#Namespaces">Namespaces</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Extended-streams.html#Extended-streams">Extended streams</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Features.html#Features">Features</a>
<hr>
</div>

<h3 class="section">2.2 Regular expression matching</h3>

<p><em>Regular expressions</em>, or "regexes", are a sophisticated way to
efficiently match patterns of text.  If you are unfamiliar with regular
expressions in general, see <a href="../emacs/Regexps.html#Regexps">Syntax of Regular Expressions</a>, for a
guide for those who have never used regular expressions.

   <p><span class="sc">gnu</span> Smalltalk supports regular expressions in the core image with methods
on <code>String</code>.

   <p>The GNU <span class="sc">gnu</span> Smalltalk expression library is derived from GNU libc,
with modifications made originally for Ruby to support Perl-like syntax. 
It will always use its included library, and never the ones installed on
your system; this may change in the future in backwards-compatible ways. 
Regular expressions are currently 8-bit clean, meaning they can
work with any ordinary String, but do not support full Unicode, even
when package <code>I18N</code> is loaded.

   <p>Broadly speaking, these regexes support Perl 5 syntax; register groups
`<samp><span class="samp">()</span></samp>' and repetition `<samp><span class="samp">{}</span></samp>' must not be given with backslashes,
and their counterpart literal characters should.  For example,
`<samp><span class="samp">\{{1,3}</span></samp>' matches `<samp><span class="samp">{</span></samp>', `<samp><span class="samp">{{</span></samp>', `<samp><span class="samp">{{{</span></samp>';
correspondingly, `<samp><span class="samp">(a)(\()</span></samp>' matches `<samp><span class="samp">a(</span></samp>', with `<samp><span class="samp">a</span></samp>' and
`<samp><span class="samp">(</span></samp>' as the first and second register groups respectively. 
<span class="sc">gnu</span> Smalltalk also supports the regex modifiers `<samp><span class="samp">imsx</span></samp>', as in Perl.  You can't
put regex modifiers like `<samp><span class="samp">im</span></samp>' after Smalltalk strings to
specify them, because they aren't part of Smalltalk syntax.  Instead,
use the inline modifier syntax.  For example, `<samp><span class="samp">(?is:abc.)</span></samp>'
is equivalent to `<samp><span class="samp">[Aa][Bb][Cc](?:.|\n)</span></samp>'.

   <p>In most cases, you should specify regular expressions as ordinary
strings.  <span class="sc">gnu</span> Smalltalk always caches compiled regexes, and uses a special
high-efficiency caching when looking up literal strings (i.e. most
regexes), to hide the compiled <code>Regex</code> objects from most code. 
For special cases where this caching is not good enough, simply send
<code>#asRegex</code> to a string to retrieved a compiled form, which
works in all places in the public API where you would specify a regex
string.  You should always rely on the cache until you have demonstrated
that using Regex objects makes a noticeable performance difference in
your code.

   <p>Smalltalk strings only have one escape, the `<samp><span class="samp">'</span></samp>' given by
`<samp><span class="samp">''</span></samp>', so backslashes used in regular expression strings will be
understood as backslashes, and a literal backslash can be given directly
with `<samp><span class="samp">\\</span></samp>'<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>.

   <p>The methods on the compiled Regex object are private to this interface. 
As a public interface, <span class="sc">gnu</span> Smalltalk provides methods on String, in the category
`<samp><span class="samp">regex</span></samp>'.  There are several methods for matching, replacing, pattern
expansion, iterating over matches, and other useful things.

   <p>The fundamental operator is <code>#searchRegex:</code>, usually written as
<code>#=~</code>, reminiscent of Perl syntax.  This method will always
return a <code>RegexResults</code>, which you can query for whether
the regex matched, the location Interval and contents of the match and
any register groups as a collection, and other features.  For example,
here is a simple configuration file line parser:

<pre class="example">     | file config |
     config := LookupTable new.
     file := (File name: 'myapp.conf') readStream.
     file linesDo: [:line |
         (line =~ '(\w+)\s*=\s*((?: ?\w+)+)') ifMatched: [:match |
             config at: (match at: 1) put: (match at: 2)]].
     file close.
     config printNl.
</pre>
   <p>As with Perl, <code>=~</code> will scan the entire string and answer the
leftmost match if any is to be found, consuming as many characters as
possible from that position.  You can anchor the search with variant
messages like <code>#matchRegex:</code>, or of course <code>^</code> and
<code>$</code> with their usual semantics if you prefer.

   <p>You shouldn't modify the string while you want a particular RegexResults
object matched on it to remain valid, because changes to the matched
text may propagate to the RegexResults object. 
<!-- (currently "will", but best to leave open) -->

   <p>Analogously to the Perl <code>s</code> operator, <span class="sc">gnu</span> Smalltalk provides
<code>#replacingRegex:with:</code>.  Unlike Perl, <span class="sc">gnu</span> Smalltalk employs the pattern expansion
syntax of the <code>#%</code> message here.  For example, <code>'The ratio is
16/9.' replacingRegex: '(\d+)/(\d+)' with: '$%1\over%2$'</code> answers
<code>'The ratio is $16\over9$.'</code>.  In place of the <code>g</code>
modifier, use the <code>#replacingAllRegex:with:</code> message instead.

   <p>One other interesting String message is <code>#onOccurrencesOfRegex:do:</code>, which
invokes its second argument, a block, on every successful match found in the
receiver.  Internally, every search will start at the end of the previous
successful match.  For example, this will print all the words in a stream:

<pre class="example">     stream contents onOccurrencesOfRegex: '\w+'
                     do: [:each | each match printNl]
</pre>
   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Whereas it must be given as `<samp><span class="samp">\\\\</span></samp>'
in a literal Emacs Lisp string, for example.</p>

   <p><hr></div>

   </body></html>

