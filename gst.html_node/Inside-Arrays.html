<html lang="en">
<head>
<title>Inside Arrays - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Behind-the-scenes.html#Behind-the-scenes" title="Behind the scenes">
<link rel="next" href="Two-flavors-of-equality.html#Two-flavors-of-equality" title="Two flavors of equality">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Inside-Arrays"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Two-flavors-of-equality.html#Two-flavors-of-equality">Two flavors of equality</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Behind-the-scenes.html#Behind-the-scenes">Behind the scenes</a>
<hr>
</div>

<h4 class="subsection">6.12.1 How Arrays Work</h4>

<p>Smalltalk provides a very adequate selection of predefined
classes from which to choose.  Eventually, however,
you will find the need to code a new basic data structure. 
Because Smalltalk's most fundamental storage allocation
facilities are arrays, it is important that you understand
how to use them to gain efficient access to this kind of
storage.

   <p><b>The Array Class.</b> Our examples have already shown the Array class, and
its use is fairly obvious.  For many applications, it will
fill all your needs&mdash;when you need an array in a new class,
you keep an instance variable, allocate a new Array and
assign it to the variable, and then send array accesses via
the instance variable.

   <p>This technique even works for string-like objects,
although it is wasteful of storage.  An Array object uses a
Smalltalk pointer for each slot in the array; its exact size
is transparent to the programmer, but you can generally
guess that it'll be roughly the word size of your machine. 
<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a> For storing an array of characters, therefore,
an Array works but is inefficient.

   <p><b>Arrays at a Lower Level.</b> So let's step down to a lower level of data
structure.  A ByteArray is much like an Array, but each slot holds only
an integer from 0 to 255-and each slot uses only a byte of
storage.  If you only needed to store small quantities in
each array slot, this would therefore be a much more efficient
choice than an Array.  As you might guess, this is the
type of array which a String uses.

   <p>Aha!  But when you go back to chapter 9 and look at the
Smalltalk hierarchy, you notice that String does not inherit
from ByteArray.  To see why, we must delve down yet another
level, and arrive at the basic methods for setting up the
structure of the instances of a class.

   <p>When we implemented our NiledArray example, we used
<code>&lt;shape: #inherit&gt;</code>.  The shape is exactly that:
the fundamental structure of Smalltalk objects created within a given
class.  Let's consider the differences in the next sub-sections.

     <dl>
<dt>Nothing<dd>The default shape specifies the simplest
Smalltalk object.  The object consists only of the storage
needed to hold the instance variables.  In C, this would be
a simple structure with zero or more scalar fields.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>.

     <br><dt><code>#pointer</code><dd>Storage is still allocated for any instance
variables, but the objects of the class must be created with a
<code>new:</code> message. 
The number passed as an argument to <code>new:</code> causes the new
object, in addition to the space for instance variables, to
also have that many slots of unnamed (indexed) storage allocated. 
The analog in C would be to have a dynamically allocated structure
with some scalar fields, followed at its end by a array of pointers.

     <br><dt><code>#byte</code><dd>The storage allocated as specified by new: is an array of bytes. 
The analog in C would be a dynamically allocated structure with
scalar fields<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>, followed by a array of <code>char</code>.

     <br><dt><code>#word</code><dd>The storage allocated as specified by new: is an array of C unsigned longs,
which are represented in Smalltalk by Integer objects.  The analog in
C would be a dynamically allocated structure with scalar fields, followed
by an array of <code>long</code>.  This kind of subclass is only used in a few
places in Smalltalk.

     <br><dt><code>#character</code><dd>The storage allocated as specified by new: is an array of characters. 
The analog in C would be a dynamically allocated structure with
scalar fields, followed by a array of <code>char</code>. 
</dl>

   <p>There are many more shapes for more specialized usage.  All of them
specify the same kind of &ldquo;array-like&rdquo; behavior, with different
data types.

   <p>How to access this new arrays?  You already know how to access instance
variables&mdash;by name.  But there doesn't seem to be a name for this new
storage.  The way an object accesses it is to send itself
array-type messages like <code>at:</code>, <code>at:put:</code>, and so forth.

   <p>The problem is when an object wants to add a new level
of interpretation to these messages.  Consider
a Dictionary&mdash;it is a pointer-holding object
but its <code>at:</code> message is in terms of a key, not an integer
index of its storage.  Since it has redefined the <code>at:</code> message, how
does it access its fundamental storage?

   <p>The answer is that Smalltalk has defined <code>basicAt:</code> and
<code>basicAt:put:</code>, which will access the basic storage even when
the <code>at:</code> and <code>at:put:</code> messages have been defined to provide
a different abstraction.

   <p>This can get pretty confusing in the abstract, so let's
do an example to show how it's pretty simple in practice. 
Smalltalk arrays tend to start at 1; let's define an array
type whose permissible range is arbitrary.

<pre class="example">        ArrayedCollection subclass: RangedArray [
            | offset |
            &lt;comment: 'I am an Array whose base is arbitrary'&gt;
            RangedArray class &gt;&gt; new: size [
                &lt;category: 'instance creation'&gt;
                ^self new: size base: 1
            ]
            RangedArray class &gt;&gt; new: size base: b [
                &lt;category: 'instance creation'&gt;
                ^(super new: size) init: b
            ]
     
            init: b [
                &lt;category: 'init'&gt;
                offset := (b - 1).   "- 1 because basicAt: works with a 1 base"
                ^self
           ]
           rangeCheck: i [
                &lt;category: 'basic'&gt;
                (i &lt;= offset) | (i &gt; (offset + self basicSize)) ifTrue: [
                    'Bad index value: ' printOn: stderr.
                    i printOn: stderr.
                    Character nl printOn: stderr.
                    ^self error: 'illegal index'
                ]
            ]
            at: [
                self rangeCheck: i.
                ^self basicAt: i - offset
            ]
            at: i put: v [
                self rangeCheck: i.
                ^self basicAt: i- offset put: v
            ]
        ]
</pre>
   <p>The code has two parts; an initialization, which simply
records what index you wish the array to start with, and the
at: messages, which adjust the requested index so that the
underlying storage receives its 1-based index instead. 
We've included a range check; its
utility will demonstrate itself in a moment:
<pre class="example">        a := RangedArray new: 10 base: 5.
        a at: 5 put: 0
        a at: 4 put: 1
</pre>
   <p>Since 4 is below our base of 5, a range check error occurs. 
But this check can catch more than just our own misbehavior!

<pre class="example">        a do: [:x| x printNl]
</pre>
   <p>Our do: message handling is broken!  The stack backtrace
pretty much tells the story:

<pre class="example">        RangedArray&gt;&gt;#rangeCheck:
        RangedArray&gt;&gt;#at:
        RangedArray&gt;&gt;#do:
</pre>
   <p>Our code received a do: message.  We didn't define one, so
we inherited the existing do: handling.  We see that an
Integer loop was constructed, that a code block was invoked,
and that our own at: code was invoked.  When we range
checked, we trapped an illegal index.  Just by coincidence,
this version of our range checking code also dumps the
index.  We see that do: has assumed that all arrays start at
1.

   <p>The immediate fix is obvious; we implement our own do:

<pre class="example">        RangedArray extend [
            do: aBlock [
                &lt;category: 'basic'&gt;
                1 to: (self basicSize) do: [:x|
                    aBlock value: (self basicAt: x)
                ]
            ]
        ]
</pre>
   <p>But the issues start to run deep.  If our parent class
believed that it knew enough to assume a starting index of
1<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a>, why didn't it also assume that it could
call basicAt:?  The answer is that of the two choices, the designer
of the parent class chose the one which was less likely to cause
trouble; in fact all standard Smalltalk collections do have indices
starting at 1, yet not all of them are implemented so
that calling basicAt: would work.<a rel="footnote" href="#fn-5" name="fnd-5"><sup>5</sup></a>

   <p>Object-oriented methodology says that one object should be
entirely opaque to another.  But what sort of privacy should
there be between a higher class and its subclasses?  How
many assumption can a subclass make about its superclass,
and how many can the superclass make before it begins
infringing on the sovereignty of its subclasses?

   <p>Alas, there are rarely easy answers, and this is just an example. 
For this particular problem, there is an easy solution.  When the
storage need not be accessed with peak efficiency, you can use the
existing array classes.  When every access counts, having the
storage be an integral part of your own object allows for
the quickest access&mdash;but remember that when you move into this
area, inheritance and polymorphism become trickier, as
each level must coordinate its use of the underlying array
with other levels.

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> For <span class="sc">gnu</span> Smalltalk, the size of a C <code>long</code>, which
is usually 32 bits.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> C
requires one or more; zero is allowed in Smalltalk</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> This is not always true for other Smalltalk
implementations, who don't allow instance variables in variableByteSubclasses
and variableWordSubclasses.</p>

   <p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> Actually, in <span class="sc">gnu</span> Smalltalk <code>do:</code> is not the only
message assuming that.</p>

   <p class="footnote"><small>[<a name="fn-5" href="#fnd-5">5</a>]</small> Some of these classes
actually redefine <code>do:</code> for performance reasons, but they
would work even if the parent class' implementation of <code>do:</code>
was kept.</p>

   <p><hr></div>

   </body></html>

