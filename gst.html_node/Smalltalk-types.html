<html lang="en">
<head>
<title>Smalltalk types - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="C-and-Smalltalk.html#C-and-Smalltalk" title="C and Smalltalk">
<link rel="prev" href="C-data-types.html#C-data-types" title="C data types">
<link rel="next" href="Smalltalk-callin.html#Smalltalk-callin" title="Smalltalk callin">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Smalltalk-types"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Smalltalk-callin.html#Smalltalk-callin">Smalltalk callin</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="C-data-types.html#C-data-types">C data types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="C-and-Smalltalk.html#C-and-Smalltalk">C and Smalltalk</a>
<hr>
</div>

<h3 class="section">5.4 Manipulating Smalltalk data from C</h3>

<p><span class="sc">gnu</span> Smalltalk internally maps every object except Integers to a data structure
named an <dfn>OOP</dfn> (which is not an acronym for anything, as far as I
know).  An OOP is a pointer to an internal data structure; this data
structure basically adds a level of indirection in the representation of
objects, since it contains
     <ul>
<li>a pointer to the actual object data

     <li>a bunch of flags, most of which interest the garbage collection process
</ul>

   <p>This additional level of indirection makes garbage collection very
efficient, since the collector is free to move an object in memory
without updating every reference to that object in the heap, thereby
keeping the heap fully compact and allowing very fast allocation of new
objects.  However, it makes C code that wants to deal with objects even
more messy than it would be without; if you want some examples, look at
the hairy code in <span class="sc">gnu</span> Smalltalk that deals with processes.

   <p>To shield you as much as possible from the complications of doing
object-oriented programming in a non-object-oriented environment like C,
<span class="sc">gnu</span> Smalltalk provides friendly functions to map between common Smalltalk
objects and C types.  This way you can simply declare OOP variables and
then use these functions to treat their contents like C data.

   <p>These functions are passed to a module via the <code>VMProxy</code> struct a
pointer to which is passed to the module, as shown in <a href="External-modules.html#External-modules">Linking your libraries to the virtual machine</a>.  They can be
divided in two groups, those that map <em>from Smalltalk objects to C
data types</em> and those that map <em>from C data types to Smalltalk
objects</em>.

   <p>Here are those in the former group (Smalltalk to C); you can see that
they all begin with <code>OOPTo</code>:

<div class="defun">
&mdash; Function: long <b>OOPToInt</b> (<var>OOP</var>)<var><a name="index-OOPToInt-39"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is an Integer and returns the
C <code>signed long</code> for that integer. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: long <b>OOPToId</b> (<var>OOP</var>)<var><a name="index-OOPToId-40"></a></var><br>
<blockquote><p>This function returns an unique identifier for the given OOP, valid
until the OOP is garbage-collected. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: double <b>OOPToFloat</b> (<var>OOP</var>)<var><a name="index-OOPToFloat-41"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is an Integer or Float and
returns the C <code>double</code> for that object. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: long double <b>OOPToLongDouble</b> (<var>OOP</var>)<var><a name="index-OOPToLongDouble-42"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is an Integer or Float and
returns the C <code>long double</code> for that object. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>OOPToBool</b> (<var>OOP</var>)<var><a name="index-OOPToBool-43"></a></var><br>
<blockquote><p>This function returns a C integer which is true (i.e. <code>!= 0</code>) if
the given OOP is the <code>true</code> object, false (i.e. <code>== 0</code>)
otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char <b>OOPToChar</b> (<var>OOP</var>)<var><a name="index-OOPToChar-44"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is a Character and returns the
C <code>char</code> for that integer. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: wchar_t <b>OOPToWChar</b> (<var>OOP</var>)<var><a name="index-OOPToWChar-45"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is a Character or
UnicodeCharacter and returns the C <code>wchar_t</code> for that integer. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char <b>*OOPToString</b> (<var>OOP</var>)<var><a name="index-g_t_002aOOPToString-46"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is a String or ByteArray and
returns a C null-terminated <code>char *</code> with the same contents.  It is
the caller's responsibility to free the pointer and to handle possible
`<samp><span class="samp">NUL</span></samp>' characters inside the Smalltalk object. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: wchar_t <b>*OOPToWString</b> (<var>OOP</var>)<var><a name="index-g_t_002aOOPToWString-47"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is a UnicodeString and
returns a C null-terminated <code>wchar_t *</code> with the same contents.  It is
the caller's responsibility to free the pointer and to handle possible
`<samp><span class="samp">NUL</span></samp>' characters inside the Smalltalk object. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char <b>*OOPToByteArray</b> (<var>OOP</var>)<var><a name="index-g_t_002aOOPToByteArray-48"></a></var><br>
<blockquote><p>This function assumes that the passed OOP is a String or ByteArray and
returns a C <code>char *</code> with the same contents, without
null-terminating it.  It is the caller's responsibility to free the
pointer. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: PTR <b>OOPToCObject</b> (<var>OOP</var>)<var><a name="index-OOPToCObject-49"></a></var><br>
<blockquote><p>This functions assumes that the passed OOP is a kind of CObject and
returns a C <code>PTR</code> to the C data pointed to by the object. The
caller should not free the pointer, nor assume anything about its size
and contents, unless it <b>exactly</b> knows what it's doing.  A <code>PTR</code>
is a <code>void *</code> if supported, or otherwise a <code>char *</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: long <b>OOPToC</b> (<var>OOP</var>)<var><a name="index-OOPToC-50"></a></var><br>
<blockquote><p>This functions assumes that the passed OOP is a String, a ByteArray,
a CObject, or a built-in object (<code>nil</code>, <code>true</code>, <code>false</code>,
character, integer).  If the OOP is <code>nil</code>, it answers 0; else the
mapping for each object is exactly the same as for the above functions. 
Note that, even though the function is declared as returning a
<code>long</code>, you might need to cast it to either a <code>char *</code>
or <code>PTR</code>. 
</p></blockquote></div>

   <p>While special care is needed to use the functions above (you will
probably want to know at least the type of the Smalltalk object you're
converting), the functions below, which convert C data to Smalltalk
objects, are easier to use and also put objects in the incubator so that
they are not swept by a garbage collection (see <a href="Incubator.html#Incubator">Incubator</a>). These
functions all <dfn>end</dfn> with <code>ToOOP</code>, except
<code>cObjectToTypedOOP</code>:

<div class="defun">
&mdash; Function: OOP <b>intToOOP</b> (<var>long</var>)<var><a name="index-intToOOP-51"></a></var><br>
<blockquote><p>This object returns a Smalltalk <code>Integer</code> which contains the same value as
the passed C <code>long</code>.  Note that Smalltalk integers are always
signed and have a bit less of precision with respect to C longs.  On 32
bit machines, their precision is 30 bits (if unsigned) or 31 bits (if
signed); on 64 bit machines, their precision is 62 bits (if unsigned) or
63 bits (if signed). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>idToOOP</b> (<var>OOP</var>)<var><a name="index-idToOOP-52"></a></var><br>
<blockquote><p>This function returns an OOP from a unique identifier returned by
<code>OOPToId</code>.  The OOP will be the same that was passed to
<code>OOPToId</code> only if the original OOP has not been garbage-collected
since the call to <code>OOPToId</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>floatToOOP</b> (<var>double</var>)<var><a name="index-floatToOOP-53"></a></var><br>
<blockquote><p>This object returns a Smalltalk <code>FloatD</code> which contains the same value as
the passed <code>double</code>.  Unlike Integers, FloatDs have exactly the same
precision as C doubles. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>longDoubleToOOP</b> (<var>long double</var>)<var><a name="index-longDoubleToOOP-54"></a></var><br>
<blockquote><p>This object returns a Smalltalk <code>FloatQ</code> which contains the same value as
the passed <code>long double</code>.  Unlike Integers, FloatQs have exactly the same
precision as C long doubles. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>boolToOOP</b> (<var>int</var>)<var><a name="index-boolToOOP-55"></a></var><br>
<blockquote><p>This object returns a Smalltalk <code>Boolean</code> which contains the same boolean
value as the passed C <code>int</code>.  That is, the returned OOP is the sole
instance of either <code>False</code> or <code>True</code>, depending on where the
parameter is zero or not. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>charToOOP</b> (<var>char</var>)<var><a name="index-charToOOP-56"></a></var><br>
<blockquote><p>This object returns a Smalltalk <code>Character</code> which represents the same char
as the passed C <code>char</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>charToOOP</b> (<var>wchar_t</var>)<var><a name="index-charToOOP-57"></a></var><br>
<blockquote><p>This object returns a Smalltalk <code>Character</code> or <code>UnicodeCharacter</code>
which represents the same char as the passed C <code>wchar_t</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>classNameToOOP</b> (<var>char *</var>)<var><a name="index-classNameToOOP-58"></a></var><br>
<blockquote><p>This method returns the Smalltalk class (i.e. an instance of a subclass
of Class) whose name is the given parameter.  This method is slow; you
can safely cache its result. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>stringToOOP</b> (<var>char *</var>)<var><a name="index-stringToOOP-59"></a></var><br>
<blockquote><p>This method returns a String which maps to the given null-terminated C
string, or the builtin object <code>nil</code> if the parameter points to
address 0 (zero). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>wstringToOOP</b> (<var>wchar_t *</var>)<var><a name="index-wstringToOOP-60"></a></var><br>
<blockquote><p>This method returns a UnicodeString which maps to the given null-terminated C
wide string, or the builtin object <code>nil</code> if the parameter points to
address 0 (zero). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>byteArrayToOOP</b> (<var>char *, int</var>)<var><a name="index-byteArrayToOOP-61"></a></var><br>
<blockquote><p>This method returns a ByteArray which maps to the bytes that the first
parameters points to; the second parameter gives the size of the
ByteArray.  The builtin object <code>nil</code> is returned if the first
parameter points to address 0 (zero). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>symbolToOOP</b> (<var>char *</var>)<var><a name="index-symbolToOOP-62"></a></var><br>
<blockquote><p>This method returns a String which maps to the given null-terminated C
string, or the builtin object <code>nil</code> if the parameter points to
address 0 (zero). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>cObjectToOOP</b> (<var>PTR</var>)<var><a name="index-cObjectToOOP-63"></a></var><br>
<blockquote><p>This method returns a CObject which maps to the given C pointer, or the
builtin object <code>nil</code> if the parameter points to address 0 (zero). 
The returned value has no precise CType assigned. To assign one, use
<code>cObjectToTypedOOP</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>cObjectToTypedOOP</b> (<var>PTR, OOP</var>)<var><a name="index-cObjectToTypedOOP-64"></a></var><br>
<blockquote><p>This method returns a CObject which maps to the given C pointer, or the
builtin object <code>nil</code> if the parameter points to address 0 (zero). 
The returned value has the second parameter as its type; to get possible
types you can use <code>typeNameToOOP</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: OOP <b>typeNameToOOP</b> (<var>char *</var>)<var><a name="index-typeNameToOOP-65"></a></var><br>
<blockquote><p>All this method actually does is evaluating its parameter as Smalltalk
code; so you can, for example, use it in any of these ways:
     <pre class="example">          cIntType = typeNameToOOP("CIntType");
          myOwnCStructType = typeNameToOOP("MyOwnCStruct type");
     </pre>
        <p>This method is primarily used by <code>msgSendf</code> (see <a href="Smalltalk-callin.html#Smalltalk-callin">Smalltalk callin</a>),
but it can be useful if you use lower level call-in methods. This method
is slow too; you can safely cache its result. 
</p></blockquote></div>

   <p>As said above, the C to Smalltalk layer automatically puts the objects
it creates in the incubator which prevents objects from being collected
as garbage.  A plugin, however, has limited control on the incubator,
and the incubator itself is not at all useful when objects should be
kept registered for a relatively long time, and whose lives in the
registry typically overlap.

   <p>To avoid garbage collection of such object, you can use these functions,
which access a separate registry:

<div class="defun">
&mdash; Function: void <b>registerOOP</b> (<var>OOP</var>)<var><a name="index-registerOOP-66"></a></var><br>
<blockquote><p>Puts the given OOP in the registry.  If you register an object multiple
times, you will need to unregister it the same number of times.  You may
want to register objects returned by Smalltalk call-ins. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>unregisterOOP</b> (<var>OOP</var>)<var><a name="index-unregisterOOP-67"></a></var><br>
<blockquote><p>Removes an occurrence of the given OOP from the registry. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>registerOOPArray</b> (<var>OOP **, OOP **</var>)<var><a name="index-registerOOPArray-68"></a></var><br>
<blockquote><p>Tells the garbage collector that an array of objects must be made part
of the root set.  The two parameters point indirectly to the base and
the top of the array; that is, they are pointers to variables holding
the base and the top of the array: having indirect pointers allows you
to dynamically change the size of the array and even to relocate it in
memory without having to unregister and re-register it every time you
modify it.  If you register an array multiple times, you will need to
unregister it the same number of times. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>unregisterOOPArray</b> (<var>OOP **</var>)<var><a name="index-unregisterOOPArray-69"></a></var><br>
<blockquote><p>Removes the array with the given base from the registry. 
</p></blockquote></div>

   </body></html>

