<html lang="en">
<head>
<title>Handling exceptions - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Exception-handling.html#Exception-handling" title="Exception handling">
<link rel="prev" href="Raising-exceptions.html#Raising-exceptions" title="Raising exceptions">
<link rel="next" href="When-an-exception-isn_0027t-handled.html#When-an-exception-isn_0027t-handled" title="When an exception isn't handled">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Handling-exceptions"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="When-an-exception-isn_0027t-handled.html#When-an-exception-isn_0027t-handled">When an exception isn't handled</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Raising-exceptions.html#Raising-exceptions">Raising exceptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Exception-handling.html#Exception-handling">Exception handling</a>
<hr>
</div>

<h4 class="subsection">6.11.3 Handling exceptions</h4>

<p>To handle an exception when it occurs in a particular block of code,
use <code>#on:do:</code> like this:

<pre class="example">     ^[someText add: inputChar beforeIndex: i]
         on: ReadOnlyText
         do: [:sig | sig return: nil]
</pre>
   <p>This code will put a handler for <code>ReadOnlyText</code> signals on the
handler stack while the first block is executing.  If such an exception
occurs, and it is not handled by any handlers closer to the point of
signalling on the stack (known as "inner handlers"), the exception object
will pass itself to the handler block given as the do: argument.

   <p>You will almost always want to use this object to handle the exception
somehow.  There are six basic handler actions, all sent as messages to
the exception object:

     <dl>
<dt><code>return:</code><dd>Exit the block that received this #on:do:, returning the given value. 
You can also leave out the argument by sending #return, in which case
it will be nil.  If you want this handler to also handle exceptions in
whatever value you might provide, you should use #retryUsing: with a
block instead.

     <br><dt><code>retry</code><dd>Acts sort of like a "goto" by restarting the first block.  Obviously,
this can lead to an infinite loop if you don't fix the situation that
caused the exception.

     <p><code>#retry</code> is a good way to implement reinvocation upon recovery,
because it does not increase the stack height.  For example, this:

     <pre class="example">            frobnicate: n [
              ^[do some stuff with n]
                  on: SomeError
                  do: [:sig | sig return: (self frobnicate: n + 1)]
              ]
     </pre>
     <p class="noindent">should be replaced with retry:

     <pre class="example">            frobnicate: aNumber [
              | n |
              n := aNumber.
              ^[do some stuff with n]
                  on: SomeError
                  do: [:sig | n := 1 + n. sig retry]
            ]
     </pre>
     <br><dt><code>retryUsing:</code><dd>Like <code>#retry</code>, except that it effectively replaces the original
block with the one given as an argument.

     <br><dt><code>pass</code><dd>If you want to tell the exception to let an outer handler handle it,
use <code>#pass</code> instead of <code>#signal</code>.  This is just like rethrowing
a caught exception in other languages.

     <br><dt><code>resume:</code><dd>This is the really interesting one.  Instead of unwinding the stack,
this will effectively answer the argument from the <code>#signal</code> send. 
Code that sends <code>#signal</code> to resumable exceptions can use this
value, or ignore it, and continue executing.  You can also leave out
the argument, in which case the <code>#signal</code> send will answer nil. 
Exceptions that want to be resumable must register this capability by
answering <code>true</code> from the <code>#isResumable</code> method, which is
checked on every <code>#resume:</code> send.

     <br><dt><code>outer</code><dd>This is like <code>#pass</code>, but if an outer handler uses #resume:, this
handler block will be resumed  (and #outer will answer the argument
given to #resume:) rather than the piece of code that sent #signal in
the first place. 
</dl>

   <p>None of these methods return to the invoking handler block except for
<code>#outer</code>, and that only in certain cases described for it above.

   <p>Exceptions provide several more features; see the methods on the classes
<code>Signal</code> and <code>Exception</code> for the various things you can do
with them.  Fortunately, the above methods can do what you want in almost
all cases.

   <p>If you don't use one of these methods or another exception feature to exit
your handler, Smalltalk will assume that you meant to <code>sig return:</code>
whatever you answer from your handler block.  We don't recommend relying
on this; you should use an explicit <code>sig return:</code> instead.

   <p>A quick shortcut to handling multiple exception types is the
<code>ExceptionSet</code>, which allows you to have a single handler for the
exceptions of a union of classes:

<pre class="example">     ^[do some stuff with n]
         on: SomeError, ReadOnlyError
         do: [:sig | ...]
</pre>
   <p>In this code, any <code>SomeError</code> or <code>ReadOnlyError</code> signals will
be handled by the given handler block.

   </body></html>

