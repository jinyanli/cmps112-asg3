<html lang="en">
<head>
<title>Sets - GNU Smalltalk User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Smalltalk User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Some-classes.html#Some-classes" title="Some classes">
<link rel="prev" href="Arrays.html#Arrays" title="Arrays">
<link rel="next" href="Dictionaries.html#Dictionaries" title="Dictionaries">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Sets"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Dictionaries.html#Dictionaries">Dictionaries</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Arrays.html#Arrays">Arrays</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Some-classes.html#Some-classes">Some classes</a>
<hr>
</div>

<h4 class="subsection">6.2.2 A set in Smalltalk</h4>

<p>We're done with the array we've been using, so we'll
assign something new to our <code>x</code> variable.  Note that we
don't need to do anything special about the old array: the
fact that nobody is using it any more will be automatically
detected, and the memory reclaimed.  This is known as <i>garbage collection</i>
and it is generally done when Smalltalk finds that it is
running low on memory.  So, to get our new object, simply do:
<pre class="example">        x := Set new
</pre>
   <p class="noindent">which creates an empty set.  To view its contents, do:
<pre class="example">        x
</pre>
   <p>The kind of object is printed out (i.e., <code>Set</code>), and then the
members are listed within parenthesis.  Since it's empty, we
see:
<pre class="example">        Set ()
</pre>
   <p>Now let's toss some stuff into it.  We'll add the numbers 5
and 7, plus the string 'foo'.  This is also the first example
where we're using more than one statement, and thus a good place to present
the statement separator&mdash;the <code>.</code> period:

<pre class="example">        x add: 5. x add: 7. x add: 'foo'
</pre>
   <p>Like Pascal, and unlike C, statements are separated rather than
terminated.  Thus you need only use a <code>.</code> when you have finished
one statement and are starting another.  This is why our last statement,
<code>^r</code>, does not have a <code>.</code> following.  Once again like Pascal,
however, Smalltalk won't complain if your enter a spurious
statement separator after <i>the last</i> statement.

   <p>However, we can save a little typing by using a Smalltalk shorthand:

<pre class="example">        x add: 5; add: 7; add: 'foo'
</pre>
   <p>This line does exactly what the previous one did. 
The trick is that the semicolon operator causes
the message to be sent to the same object as the last message
sent.  So saying <code>; add: 7</code> is the same as saying
<code>x add: 7</code>, because <code>x</code> was the last thing a message was sent
to.

   <p>his may not seem like such a big savings, but compare
the ease when your variable is named <code>aVeryLongVariableName</code>
instead of just <code>x</code>!  We'll revisit some other occasions
where <code>;</code> saves you trouble, but for now let's continue with
our set.  Type either version of the example, and make sure
that we've added 5, 7, and &ldquo;foo&rdquo;:
<pre class="example">        x
</pre>
   <p class="noindent">we'll see that it now contains our data:
<pre class="example">        Set ('foo' 5 7)
</pre>
   <p>What if we add something twice?  No problem&mdash;it just stays in
the set.  So a set is like a big checklist&mdash;either it's in
there, or it isn't.  To wit:
<pre class="example">        x add:5; add: 5; add: 5; add: 5; yourself
</pre>
   <p>We've added <i>5</i> several times, but when we printed our set
back out, we just see:
<pre class="example">        Set ('foo' 5 7)
</pre>
   <p><code>yourself</code> is commonly sent at the end of the cascade,
if what you are interested in is the object itself&mdash;in this
case, we were not interested in the return value of <code>add: 5</code>,
which happens to be <code>5</code> simply.  There's nothing magic in
<code>yourself</code>; it is a unary message like <code>printNl</code>,
which does nothing but returning the object itself.  So you
can do this too:

<pre class="example">        x yourself
</pre>
   <p>What you put into a set with <code>add:</code>, you can take out
with <code>remove:</code>.  Try:

<pre class="example">        x remove: 5
        x printNl
</pre>
   <p>The set now prints as:
<pre class="example">        Set ('foo' 7)
</pre>
   <p>The &ldquo;5&rdquo; is indeed gone from the set.

   <p>We'll finish up with one more of the many things you
can do with a set&mdash;checking for membership.  Try:
<pre class="example">        x includes: 7
        x includes: 5
</pre>
   <p>From which we see that x does indeed contain 7, but not 5. 
Notice that the answer is printed as <code>true</code> or <code>false</code>. 
Once again, the thing returned is an object&mdash;in this case, an
object known as a boolean.  We'll look at the use of
booleans later, but for now we'll just say that booleans are
nothing more than objects which can only either be true or
false&mdash;nothing else.  So they're very useful for answers to
yes or no questions, like the ones we just posed.  Let's
take a look at just one more kind of data structure:

   </body></html>

